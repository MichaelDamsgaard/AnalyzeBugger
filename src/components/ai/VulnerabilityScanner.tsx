import { useState, useCallback, useMemo } from "react";
import { useAnalysisStore } from "../../stores/analysisStore";
import {
  Shield, ShieldAlert, ShieldCheck, Loader2, RefreshCw,
  AlertTriangle, Info, ChevronDown, ChevronRight, ExternalLink,
  Bug, Lock, Unlock, Zap
} from "lucide-react";

type VulnSeverity = "critical" | "high" | "medium" | "low" | "info";
type VulnCategory = "overflow" | "injection" | "crypto" | "auth" | "memory" | "info_leak" | "logic";

interface Vulnerability {
  id: string;
  title: string;
  description: string;
  severity: VulnSeverity;
  category: VulnCategory;
  addresses: string[];
  cwe?: string;
  mitigation: string;
  confidence: number;
  evidence: string;
}

// Vulnerability detection patterns
const VULN_PATTERNS = {
  // Buffer overflow indicators
  unsafe_functions: [
    { pattern: "strcpy", vuln: "CWE-120: Buffer Copy without Size Check" },
    { pattern: "strcat", vuln: "CWE-120: Buffer Copy without Size Check" },
    { pattern: "gets", vuln: "CWE-242: Use of Inherently Dangerous Function" },
    { pattern: "sprintf", vuln: "CWE-120: Classic Buffer Overflow" },
    { pattern: "scanf", vuln: "CWE-120: Unbounded Input" },
  ],
  // Crypto weaknesses
  weak_crypto: [
    { pattern: "md5", vuln: "CWE-328: Reversible One-Way Hash" },
    { pattern: "sha1", vuln: "CWE-328: Weak Hash Algorithm" },
    { pattern: "des", vuln: "CWE-327: Broken Cryptography" },
    { pattern: "rc4", vuln: "CWE-327: Weak Stream Cipher" },
  ],
  // Memory issues
  memory_issues: [
    { mnemonic: "rep movsb", vuln: "Potential unchecked memory copy" },
    { mnemonic: "rep stosb", vuln: "Potential memory fill without bounds" },
  ],
};

export function VulnerabilityScanner() {
  const { result, navigateTo } = useAnalysisStore();
  const [isScanning, setIsScanning] = useState(false);
  const [vulnerabilities, setVulnerabilities] = useState<Vulnerability[]>([]);
  const [expandedVuln, setExpandedVuln] = useState<Set<string>>(new Set());
  const [filterSeverity, setFilterSeverity] = useState<VulnSeverity | "all">("all");

  // Scan for vulnerabilities
  const scanVulnerabilities = useCallback(async () => {
    if (!result) return;

    setIsScanning(true);
    await new Promise((resolve) => setTimeout(resolve, 500)); // Simulate analysis time

    const found: Vulnerability[] = [];
    let vulnId = 0;

    // Analyze strings for dangerous function names
    result.strings.forEach((str) => {
      const lower = str.value.toLowerCase();

      // Check for unsafe functions
      VULN_PATTERNS.unsafe_functions.forEach(({ pattern, vuln }) => {
        if (lower.includes(pattern)) {
          found.push({
            id: `vuln-${vulnId++}`,
            title: `Unsafe Function: ${pattern}`,
            description: vuln,
            severity: pattern === "gets" ? "critical" : "high",
            category: "overflow",
            addresses: [str.offset],
            cwe: vuln.split(":")[0],
            mitigation: `Replace ${pattern} with a bounds-checked alternative like ${getSafeAlternative(pattern)}`,
            confidence: 0.9,
            evidence: `String "${str.value}" found at ${str.offset}`,
          });
        }
      });

      // Check for weak crypto
      VULN_PATTERNS.weak_crypto.forEach(({ pattern, vuln }) => {
        if (lower.includes(pattern)) {
          found.push({
            id: `vuln-${vulnId++}`,
            title: `Weak Cryptography: ${pattern.toUpperCase()}`,
            description: vuln,
            severity: "medium",
            category: "crypto",
            addresses: [str.offset],
            cwe: vuln.split(":")[0],
            mitigation: `Use modern cryptographic algorithms (AES-256, SHA-256/SHA-3)`,
            confidence: 0.85,
            evidence: `Reference to ${pattern} found at ${str.offset}`,
          });
        }
      });

      // Hardcoded credentials
      if (/(password|passwd|pwd|secret|key).*[=:]/i.test(str.value)) {
        found.push({
          id: `vuln-${vulnId++}`,
          title: "Potential Hardcoded Credential",
          description: "CWE-798: Use of Hard-coded Credentials",
          severity: "high",
          category: "auth",
          addresses: [str.offset],
          cwe: "CWE-798",
          mitigation: "Store credentials in secure configuration or use environment variables",
          confidence: 0.7,
          evidence: `String "${str.value.substring(0, 30)}..." suggests hardcoded credential`,
        });
      }
    });

    // Analyze instruction patterns
    const mnemonicPatterns: Record<string, number[]> = {};
    result.instructions.forEach((insn, idx) => {
      const m = insn.mnemonic.toLowerCase();
      const ops = insn.op_str.toLowerCase();

      // Track repeated patterns
      const key = `${m} ${ops.split(",")[0] || ""}`.trim();
      if (!mnemonicPatterns[key]) mnemonicPatterns[key] = [];
      mnemonicPatterns[key].push(idx);

      // Stack-based overflow indicators
      if (m === "sub" && ops.includes("sp") && ops.includes(",")) {
        const match = ops.match(/,\s*([0-9a-fx]+)/i);
        if (match) {
          const stackSize = parseInt(match[1], 16) || parseInt(match[1], 10);
          if (stackSize > 0x1000) {
            found.push({
              id: `vuln-${vulnId++}`,
              title: "Large Stack Allocation",
              description: "Large stack buffer may be vulnerable to overflow",
              severity: "low",
              category: "overflow",
              addresses: [insn.address],
              mitigation: "Validate buffer sizes and use heap allocation for large buffers",
              confidence: 0.5,
              evidence: `Stack allocation of ${stackSize} bytes at ${insn.address}`,
            });
          }
        }
      }

      // XOR-based obfuscation/encryption
      if (m === "xor" && !ops.includes(",0") && !isSelfXor(ops)) {
        // Track for potential crypto analysis
      }

      // INT 21h DOS calls - check for dangerous operations
      if (m === "int" && (ops === "21h" || ops === "0x21")) {
        // Look backwards for function number in AH
        for (let j = idx - 1; j >= Math.max(0, idx - 5); j--) {
          const prevInsn = result.instructions[j];
          if (prevInsn.mnemonic.toLowerCase() === "mov" &&
              prevInsn.op_str.toLowerCase().startsWith("ah,")) {
            const ahVal = prevInsn.op_str.split(",")[1]?.trim().toLowerCase();
            if (ahVal === "3ch" || ahVal === "0x3c" || ahVal === "3c") {
              found.push({
                id: `vuln-${vulnId++}`,
                title: "File Creation Capability",
                description: "Program can create files (DOS INT 21h/3Ch)",
                severity: "info",
                category: "info_leak",
                addresses: [insn.address],
                mitigation: "Review file creation for potential data exfiltration",
                confidence: 0.9,
                evidence: `File create syscall at ${insn.address}`,
              });
            }
            if (ahVal === "4bh" || ahVal === "0x4b" || ahVal === "4b") {
              found.push({
                id: `vuln-${vulnId++}`,
                title: "Program Execution Capability",
                description: "CWE-78: OS Command Injection - Program can execute other programs",
                severity: "high",
                category: "injection",
                addresses: [insn.address],
                cwe: "CWE-78",
                mitigation: "Validate and sanitize any user input before execution",
                confidence: 0.95,
                evidence: `EXEC syscall (INT 21h/4Bh) at ${insn.address}`,
              });
            }
            break;
          }
        }
      }
    });

    // Detect XOR loops (potential encryption/obfuscation)
    const xorCount = result.instructions.filter(
      (i) => i.mnemonic.toLowerCase() === "xor" && !isSelfXor(i.op_str.toLowerCase())
    ).length;
    if (xorCount > 5) {
      found.push({
        id: `vuln-${vulnId++}`,
        title: "Encryption/Obfuscation Detected",
        description: "Multiple XOR operations suggest encryption or obfuscation",
        severity: "info",
        category: "crypto",
        addresses: [],
        mitigation: "Analyze XOR patterns to understand encryption scheme",
        confidence: 0.6,
        evidence: `${xorCount} XOR instructions found - common in simple encryption`,
      });
    }

    // Check MITRE techniques for security implications
    if (result.mitre_techniques) {
      result.mitre_techniques.forEach((technique: { id: string; name: string; tactic: string }) => {
        if (technique.tactic === "Defense Evasion" || technique.tactic === "Persistence") {
          found.push({
            id: `vuln-${vulnId++}`,
            title: `Malicious Technique: ${technique.name}`,
            description: `MITRE ATT&CK ${technique.id}: ${technique.name}`,
            severity: "high",
            category: "logic",
            addresses: [],
            mitigation: "Review code for malicious intent",
            confidence: 0.8,
            evidence: `Technique ${technique.id} detected`,
          });
        }
      });
    }

    // Sort by severity
    const severityOrder: Record<VulnSeverity, number> = {
      critical: 0,
      high: 1,
      medium: 2,
      low: 3,
      info: 4,
    };
    found.sort((a, b) => severityOrder[a.severity] - severityOrder[b.severity]);

    setVulnerabilities(found);
    setIsScanning(false);
  }, [result]);

  // Filter vulnerabilities
  const filteredVulns = useMemo(() => {
    if (filterSeverity === "all") return vulnerabilities;
    return vulnerabilities.filter((v) => v.severity === filterSeverity);
  }, [vulnerabilities, filterSeverity]);

  // Severity counts
  const severityCounts = useMemo(() => {
    const counts: Record<VulnSeverity | "total", number> = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0,
      total: vulnerabilities.length,
    };
    vulnerabilities.forEach((v) => counts[v.severity]++);
    return counts;
  }, [vulnerabilities]);

  const toggleExpand = (id: string) => {
    const newExpanded = new Set(expandedVuln);
    if (newExpanded.has(id)) {
      newExpanded.delete(id);
    } else {
      newExpanded.add(id);
    }
    setExpandedVuln(newExpanded);
  };

  if (!result) {
    return (
      <div className="h-full flex items-center justify-center text-text-secondary">
        <div className="text-center">
          <Shield className="w-10 h-10 mx-auto mb-3 opacity-50" />
          <p className="text-sm">AI Vulnerability Scanner</p>
          <p className="text-xs mt-1">Analyze a file to scan for vulnerabilities</p>
        </div>
      </div>
    );
  }

  return (
    <div className="h-full flex flex-col">
      {/* Header */}
      <div className="h-10 bg-gradient-to-r from-accent-red/20 to-accent-orange/20 border-b border-border flex items-center justify-between px-3">
        <div className="flex items-center gap-2">
          <ShieldAlert className="w-5 h-5 text-accent-red" />
          <span className="text-sm font-medium">Vulnerability Scanner</span>
          <span className="px-1.5 py-0.5 text-[10px] bg-accent-red/20 text-accent-red rounded">
            AI-Powered
          </span>
        </div>
        <button
          onClick={scanVulnerabilities}
          disabled={isScanning}
          className="flex items-center gap-1 px-3 py-1 text-xs bg-accent-red/20 text-accent-red rounded hover:bg-accent-red/30 disabled:opacity-50"
        >
          {isScanning ? (
            <Loader2 className="w-3 h-3 animate-spin" />
          ) : (
            <RefreshCw className="w-3 h-3" />
          )}
          {isScanning ? "Scanning..." : "Scan"}
        </button>
      </div>

      {/* Summary bar */}
      {vulnerabilities.length > 0 && (
        <div className="h-8 bg-bg-tertiary border-b border-border flex items-center px-3 gap-3 text-xs">
          <span className="text-text-secondary">Found:</span>
          {severityCounts.critical > 0 && (
            <button
              onClick={() => setFilterSeverity(filterSeverity === "critical" ? "all" : "critical")}
              className={`flex items-center gap-1 px-2 py-0.5 rounded ${
                filterSeverity === "critical" ? "bg-red-500/30" : ""
              }`}
            >
              <span className="w-2 h-2 rounded-full bg-red-500" />
              {severityCounts.critical} Critical
            </button>
          )}
          {severityCounts.high > 0 && (
            <button
              onClick={() => setFilterSeverity(filterSeverity === "high" ? "all" : "high")}
              className={`flex items-center gap-1 px-2 py-0.5 rounded ${
                filterSeverity === "high" ? "bg-orange-500/30" : ""
              }`}
            >
              <span className="w-2 h-2 rounded-full bg-orange-500" />
              {severityCounts.high} High
            </button>
          )}
          {severityCounts.medium > 0 && (
            <button
              onClick={() => setFilterSeverity(filterSeverity === "medium" ? "all" : "medium")}
              className={`flex items-center gap-1 px-2 py-0.5 rounded ${
                filterSeverity === "medium" ? "bg-yellow-500/30" : ""
              }`}
            >
              <span className="w-2 h-2 rounded-full bg-yellow-500" />
              {severityCounts.medium} Medium
            </button>
          )}
          {(severityCounts.low > 0 || severityCounts.info > 0) && (
            <button
              onClick={() => setFilterSeverity("all")}
              className="flex items-center gap-1 px-2 py-0.5 text-text-secondary"
            >
              +{severityCounts.low + severityCounts.info} Info/Low
            </button>
          )}
        </div>
      )}

      {/* Vulnerability list */}
      <div className="flex-1 overflow-auto">
        {vulnerabilities.length === 0 ? (
          <div className="h-full flex items-center justify-center text-text-secondary">
            <div className="text-center max-w-xs">
              <ShieldCheck className="w-8 h-8 mx-auto mb-3 opacity-50" />
              <p className="text-sm font-medium">No vulnerabilities found yet</p>
              <p className="text-xs mt-2">
                Click "Scan" to analyze the binary for potential security issues,
                dangerous functions, and vulnerability patterns.
              </p>
            </div>
          </div>
        ) : (
          <div className="divide-y divide-border">
            {filteredVulns.map((vuln) => (
              <div key={vuln.id} className="bg-bg-primary">
                {/* Vulnerability header */}
                <button
                  onClick={() => toggleExpand(vuln.id)}
                  className="w-full px-3 py-2 flex items-center gap-2 hover:bg-bg-hover transition-colors text-left"
                >
                  {expandedVuln.has(vuln.id) ? (
                    <ChevronDown className="w-4 h-4 text-text-secondary shrink-0" />
                  ) : (
                    <ChevronRight className="w-4 h-4 text-text-secondary shrink-0" />
                  )}

                  {/* Severity badge */}
                  <span
                    className={`w-2 h-2 rounded-full shrink-0 ${getSeverityColor(vuln.severity)}`}
                  />

                  {/* Icon */}
                  {getCategoryIcon(vuln.category)}

                  {/* Title */}
                  <span className="text-sm font-medium flex-1 truncate">
                    {vuln.title}
                  </span>

                  {/* CWE badge */}
                  {vuln.cwe && (
                    <span className="px-1.5 py-0.5 text-[10px] bg-bg-tertiary text-text-secondary rounded">
                      {vuln.cwe}
                    </span>
                  )}

                  {/* Severity label */}
                  <span
                    className={`px-1.5 py-0.5 text-[10px] rounded ${getSeverityBadge(vuln.severity)}`}
                  >
                    {vuln.severity.toUpperCase()}
                  </span>

                  {/* Confidence */}
                  <span className="text-[10px] text-text-secondary">
                    {Math.round(vuln.confidence * 100)}%
                  </span>
                </button>

                {/* Expanded details */}
                {expandedVuln.has(vuln.id) && (
                  <div className="px-4 pb-3 space-y-3 bg-bg-tertiary/30">
                    {/* Description */}
                    <div className="p-2 bg-bg-tertiary rounded text-sm">
                      {vuln.description}
                    </div>

                    {/* Evidence */}
                    <div className="flex items-start gap-2 text-xs">
                      <Bug className="w-4 h-4 text-accent-orange shrink-0 mt-0.5" />
                      <div>
                        <span className="font-semibold text-accent-orange">Evidence:</span>
                        <p className="text-text-secondary mt-0.5">{vuln.evidence}</p>
                      </div>
                    </div>

                    {/* Affected addresses */}
                    {vuln.addresses.length > 0 && (
                      <div className="flex items-start gap-2 text-xs">
                        <ExternalLink className="w-4 h-4 text-accent-blue shrink-0 mt-0.5" />
                        <div>
                          <span className="font-semibold text-accent-blue">Location(s):</span>
                          <div className="flex flex-wrap gap-1 mt-1">
                            {vuln.addresses.map((addr, i) => (
                              <button
                                key={i}
                                onClick={() => navigateTo(addr)}
                                className="px-2 py-0.5 bg-bg-primary hover:bg-bg-hover rounded font-mono text-accent-blue"
                              >
                                {addr}
                              </button>
                            ))}
                          </div>
                        </div>
                      </div>
                    )}

                    {/* Mitigation */}
                    <div className="flex items-start gap-2 text-xs">
                      <ShieldCheck className="w-4 h-4 text-accent-green shrink-0 mt-0.5" />
                      <div>
                        <span className="font-semibold text-accent-green">Mitigation:</span>
                        <p className="text-text-secondary mt-0.5">{vuln.mitigation}</p>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Footer */}
      <div className="h-5 bg-bg-secondary border-t border-border flex items-center justify-between px-3 text-[10px] text-text-secondary shrink-0">
        <span>{vulnerabilities.length} vulnerabilities detected</span>
        <span>AI-powered static analysis</span>
      </div>
    </div>
  );
}

// Helper functions
function getSeverityColor(severity: VulnSeverity): string {
  switch (severity) {
    case "critical":
      return "bg-red-500";
    case "high":
      return "bg-orange-500";
    case "medium":
      return "bg-yellow-500";
    case "low":
      return "bg-blue-500";
    case "info":
      return "bg-gray-500";
  }
}

function getSeverityBadge(severity: VulnSeverity): string {
  switch (severity) {
    case "critical":
      return "bg-red-500/20 text-red-400";
    case "high":
      return "bg-orange-500/20 text-orange-400";
    case "medium":
      return "bg-yellow-500/20 text-yellow-400";
    case "low":
      return "bg-blue-500/20 text-blue-400";
    case "info":
      return "bg-gray-500/20 text-gray-400";
  }
}

function getCategoryIcon(category: VulnCategory) {
  const className = "w-4 h-4 text-text-secondary shrink-0";
  switch (category) {
    case "overflow":
      return <AlertTriangle className={className} />;
    case "injection":
      return <Zap className={className} />;
    case "crypto":
      return <Lock className={className} />;
    case "auth":
      return <Unlock className={className} />;
    case "memory":
      return <Bug className={className} />;
    case "info_leak":
      return <Info className={className} />;
    case "logic":
      return <Bug className={className} />;
    default:
      return <Shield className={className} />;
  }
}

function getSafeAlternative(unsafeFunc: string): string {
  const alternatives: Record<string, string> = {
    strcpy: "strncpy or strlcpy",
    strcat: "strncat or strlcat",
    gets: "fgets",
    sprintf: "snprintf",
    scanf: "fgets + sscanf",
  };
  return alternatives[unsafeFunc] || "bounds-checked version";
}

function isSelfXor(ops: string): boolean {
  const parts = ops.split(",").map((s) => s.trim());
  return parts.length === 2 && parts[0] === parts[1];
}
